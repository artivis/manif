<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="md_pages_cpp__on_the_use_with__ceres" kind="page">
    <compoundname>md_pages_cpp_On_the_use_with_Ceres</compoundname>
    <title>Ceres</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><itemizedlist>
<listitem><para><ulink url="#ceres">Ceres</ulink><itemizedlist>
<listitem><para><ulink url="#jacobians">Jacobians</ulink></para>
</listitem><listitem><para><ulink url="#example--a-group-abstract-localparameterization">Example : A group-abstract LocalParameterization</ulink></para>
</listitem><listitem><para><ulink url="#example--a-small-ceres-problem">Example : A small Ceres problem</ulink></para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
<para>The <bold>manif</bold> package differentiates Jacobians with respect to a local perturbation on the tangent space. These Jacobians map tangent spaces, as described in <ulink url="http://arxiv.org/abs/1812.01537">this paper</ulink>.</para>
<para>However, many non-linear solvers (e.g. <ulink url="http://ceres-solver.org/">Ceres</ulink>) expect functions to be differentiated with respect to the underlying representation vector of the group element (e.g. with respect to quaternion vector for <computeroutput>SO3</computeroutput>).</para>
<para>For this reason <bold>manif</bold> is compliant with <ulink url="http://ceres-solver.org/">Ceres</ulink> auto-differentiation and the <ulink url="http://ceres-solver.org/automatic_derivatives.html#dual-numbers-jets"><computeroutput>ceres::Jet</computeroutput></ulink> type.</para>
<para>For reference of the size of the Jacobians returned when using <computeroutput>ceres::Jet</computeroutput>, <bold>manif</bold> implements rotations in the following way:</para>
<para><itemizedlist>
<listitem><para>SO(2) and SE(2): as a complex number with <computeroutput>real = cos(theta)</computeroutput> and <computeroutput>imag = sin(theta)</computeroutput> values.</para>
</listitem><listitem><para>SO(3), SE(3) and SE_2(3): as a unit quaternion, using the underlying <computeroutput>Eigen::Quaternion</computeroutput> type.</para>
</listitem></itemizedlist>
</para>
<para>Therefore, the respective Jacobian sizes using <computeroutput>ceres::Jet</computeroutput> are as follows:</para>
<para><itemizedlist>
<listitem><para>‚Ñù(n) : size n</para>
</listitem><listitem><para>SO(2) : size 2</para>
</listitem><listitem><para>SO(3) : size 4</para>
</listitem><listitem><para>SE(2) : size 4</para>
</listitem><listitem><para>SE(3) : size 7</para>
</listitem><listitem><para>SE_2(3): size 10</para>
</listitem></itemizedlist>
</para>
<sect1 id="md_pages_cpp__on_the_use_with__ceres_1autotoc_md4">
<title>Jacobians</title>
<para>Considering,</para>
<para><image type="html" name="https://latex.codecogs.com/svg.latex?\color{white}\bf&amp;space;x" alt="x" inline="yes"></image>
 a group element (e.g. S3), <image type="html" name="https://latex.codecogs.com/svg.latex?\color{white}\omega" alt="omega" inline="yes"></image>
 the vector tangent to the group at <image type="html" name="https://latex.codecogs.com/svg.latex?\color{white}\bf&amp;space;x" alt="x" inline="yes"></image>
, <image type="html" name="https://latex.codecogs.com/svg.latex?\color{white}{\bf&amp;space;e}=f({\bf&amp;space;x})" alt="f(x)" inline="yes"></image>
 an error function,</para>
<para>one is interested in expressing the Taylor series of the error function,</para>
<para><image type="html" name="https://latex.codecogs.com/svg.latex?\color{white}f({\bf&amp;space;x\oplus\omega})\approx{\bf&amp;space;e}+{\bf&amp;space;J}_{\omega}^{e}~\omega&amp;space;." alt="f(x(+)omega)" inline="yes"></image>
</para>
<para>Therefore we have to compute the Jacobian</para>
<para><image type="html" name="https://latex.codecogs.com/svg.latex?\color{white}{\bf&amp;space;J}_{\omega}^{e}=\frac{\delta{\bf&amp;space;e}}{\delta{\bf&amp;space;x}}=\frac{\delta&amp;space;f({\bf&amp;space;x})}{\delta{\bf&amp;space;x}}=\lim_{\omega\to0}\frac{f({\bf&amp;space;x}\oplus\omega)\ominus&amp;space;f({\bf&amp;space;x})}{\omega},&amp;space;(1)" alt="J_e_omega" inline="yes"></image>
</para>
<para>the <bold>Jacobian of</bold> <image type="html" name="https://latex.codecogs.com/svg.latex?\color{white}f({\bf&amp;space;x})" alt="f(x)" inline="yes"></image>
 <bold>with respect to a perturbation on the tangent space</bold>, so that the state update happens on the manifold tangent space.</para>
<para>In Ceres&apos; framework, the computation of this Jacobian is decoupled in two folds as explained hereafter. The following terminology should sounds familiar to Ceres users.</para>
<para>Ceres <ulink url="http://ceres-solver.org/nnls_modeling.html#costfunction"><computeroutput>CostFunction</computeroutput></ulink> is the class representing and implementing a function <image type="html" name="https://latex.codecogs.com/svg.latex?\color{white}{\bf&amp;space;e}=f({\bf&amp;space;x})" alt="f(x)" inline="yes"></image>
, for instance,</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">QuadraticCostFunction<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/>ceres::SizedCostFunction&lt;1,<sp/>1&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~QuadraticCostFunction()<sp/>{}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>Evaluate(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">*<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal">*<sp/>parameters,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>residuals,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">**<sp/>jacobians)</highlight><highlight class="keyword"><sp/>const<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>x<sp/>=<sp/>parameters[0][0];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>residuals[0]<sp/>=<sp/>10<sp/>-<sp/>x;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Compute<sp/>the<sp/>Jacobian<sp/>if<sp/>asked<sp/>for.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(jacobians<sp/>!=<sp/>NULL<sp/>&amp;&amp;<sp/>jacobians[0]<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>jacobians[0][0]<sp/>=<sp/>-1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>It produces the Jacobian,</para>
<para><image type="html" name="https://latex.codecogs.com/svg.latex?\color{white}{\bf&amp;space;J}_{{\bf&amp;space;x}\oplus\omega}^{e}=\frac{\delta{\bf&amp;space;e}}{\delta({\bf&amp;space;x}\oplus\omega)}=\lim_{\mathbf&amp;space;h\to0}\frac{&amp;space;f({\bf&amp;space;x}+\mathbf&amp;space;h)-f({\bf&amp;space;x})}{\mathbf&amp;space;h}.&amp;space;(2)" alt="J_e_x(+)omega" inline="yes"></image>
</para>
<para>In Ceres, a <ulink url="http://ceres-solver.org/nnls_modeling.html#localparameterization"><computeroutput>LocalParameterization</computeroutput></ulink> can be associated to a state.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">Eigen::Quaterniond<sp/>my_state;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ceres::Problem::Options<sp/>problem_options;</highlight></codeline>
<codeline><highlight class="normal">ceres::Problem<sp/>problem(problem_options);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Add<sp/>the<sp/>state<sp/>to<sp/>Ceres<sp/>problem</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">problem-&gt;AddParameterBlock(my_state.data(),<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Associate<sp/>a<sp/>LocalParameterization<sp/>to<sp/>the<sp/>state<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">problem_-&gt;SetManifold(my_state.data(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>EigenQuaternionParameterization()<sp/>);</highlight></codeline>
</programlisting></para>
<para>The <computeroutput>LocalParameterization</computeroutput> class (and derived) performs the state update step of the optimization - the <image type="html" name="https://latex.codecogs.com/svg.latex?\color{white}{\bf&amp;space;x}\oplus\mathbf\omega" alt="x(+)omega" inline="yes"></image>
 operation. While the function operates for any <image type="html" name="https://latex.codecogs.com/svg.latex?\color{white}\mathbf\omega" alt="omega" inline="yes"></image>
, its Jacobian is evaluated for <image type="html" name="https://latex.codecogs.com/svg.latex?\color{white}\omega=0" alt="omega=0" inline="yes"></image>
 thus providing the Jacobian,</para>
<para><image type="html" name="https://latex.codecogs.com/svg.latex?\color{white}{\bf&amp;space;J}_{\omega}^{{\bf&amp;space;x}\oplus\omega}=\frac{\delta({\bf&amp;space;x}\oplus\omega)}{\delta\omega}=\lim_{\delta\omega\to0}\frac{{\bf&amp;space;x}\oplus(\omega+\delta\omega)-{\bf&amp;space;x}\oplus\mathbf\omega}{\delta\omega}=\lim_{\delta\omega\to0}\frac{{\bf&amp;space;x}\oplus\delta\omega-{\bf&amp;space;x}}{\delta\omega}.&amp;space;(3)" alt="J_x(+)w_w" inline="yes"></image>
</para>
<para>Once both the <computeroutput>CostFunction</computeroutput> and <computeroutput>LocalParameterization</computeroutput>&apos;s Jacobians are evaluated, <computeroutput>Ceres</computeroutput> internally computes <computeroutput>(1)</computeroutput> with the following product,</para>
<para><image type="html" name="https://latex.codecogs.com/svg.latex?\color{white}{\bf&amp;space;J}_{\omega}^{e}={\bf&amp;space;J}_{{\bf&amp;space;x}\oplus\omega}^{e}\times{\bf&amp;space;J}_{\omega}^{{\bf&amp;space;x}\oplus\omega}.&amp;space;(4)" alt="J_e_w = J_e_x(+)omega * J_x(+)w_w" inline="yes"></image>
</para>
<para>Voila.</para>
<para>The intermediate Jacobians (2-3) that <computeroutput>Ceres</computeroutput> requires are <bold>not</bold> available in <computeroutput>manif</computeroutput> since it provide directly the final Jacobian detailed in <computeroutput>(1)</computeroutput>.</para>
<para>However, one still wants to use <computeroutput>manif</computeroutput> with his <computeroutput>Ceres</computeroutput>-based project. For this reason, <computeroutput>manif</computeroutput> is compliant with <computeroutput>Ceres</computeroutput> auto-differentiation and the <ulink url="http://ceres-solver.org/automatic_derivatives.html#dual-numbers-jets"><computeroutput>ceres::Jet</computeroutput></ulink> type to compute (2-3).</para>
<para>Below are presented two small examples illustrating how <computeroutput>manif</computeroutput> can be used with <computeroutput>Ceres</computeroutput>.</para>
</sect1>
<sect1 id="md_pages_cpp__on_the_use_with__ceres_1autotoc_md5">
<title>Example : A group-abstract LocalParameterization</title>
<para>Is shown here how one can implement a <computeroutput>ceres::LocalParameterization</computeroutput>-derived class using <computeroutput>manif</computeroutput>, that does the <image type="html" name="https://latex.codecogs.com/svg.latex?\color{white}{\bf&amp;space;x}\oplus\mathbf\omega" alt="x(+)omega" inline="yes"></image>
 for any group implemented in <computeroutput>manif</computeroutput> passed as a template parameter.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>_LieGroup&gt;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">CeresLocalParameterization</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>LieGroup<sp/>=<sp/>_LieGroup;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>Tangent<sp/><sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>_LieGroup::Tangent;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>_Scalar&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>LieGroupTemplate<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>LieGroup::template<sp/>LieGroupTemplate&lt;_Scalar&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal"><sp/>&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>_Scalar&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>TangentTemplate<sp/>=<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>Tangent::template<sp/>TangentTemplate&lt;_Scalar&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CeresLocalParameterizationFunctor()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/>~CeresLocalParameterizationFunctor()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>T&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>operator()(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T*<sp/>state_raw,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>T*<sp/>delta_raw,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>T*<sp/>state_plus_delta_raw)</highlight><highlight class="keyword"><sp/>const</highlight></codeline>
<codeline><highlight class="keyword"><sp/><sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Eigen::Map&lt;const<sp/>LieGroupTemplate&lt;T&gt;&gt;<sp/>state(state_raw);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>Eigen::Map&lt;const<sp/>TangentTemplate&lt;T&gt;&gt;<sp/><sp/>delta(delta_raw);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Eigen::Map&lt;LieGroupTemplate&lt;T&gt;&gt;<sp/>state_plus_delta(state_plus_delta_raw);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>state_plus_delta<sp/>=<sp/>state<sp/>+<sp/>delta;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Some<sp/>typedef<sp/>helpers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">using<sp/>CeresLocalParameterizationSO2<sp/>=<sp/>CeresLocalParameterizationFunctor&lt;SO2d&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>CeresLocalParameterizationSE2<sp/>=<sp/>CeresLocalParameterizationFunctor&lt;SE2d&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>CeresLocalParameterizationSO3<sp/>=<sp/>CeresLocalParameterizationFunctor&lt;SO3d&gt;;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">using</highlight><highlight class="normal"><sp/>CeresLocalParameterizationSE3<sp/>=<sp/>CeresLocalParameterizationFunctor&lt;SE3d&gt;;</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="md_pages_cpp__on_the_use_with__ceres_1autotoc_md6">
<title>Example : A small Ceres problem</title>
<para>This example highlights the use of the predefined <computeroutput>Ceres</computeroutput> helper classes available with <computeroutput>manif</computeroutput>. In this example, we compute an average point from 4 points in <computeroutput>SE2</computeroutput>.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Tell<sp/>ceres<sp/>not<sp/>to<sp/>take<sp/>ownership<sp/>of<sp/>the<sp/>raw<sp/>pointers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ceres::Problem::Options<sp/>problem_options;</highlight></codeline>
<codeline><highlight class="normal">problem_options.cost_function_ownership<sp/>=<sp/>ceres::DO_NOT_TAKE_OWNERSHIP;</highlight></codeline>
<codeline><highlight class="normal">problem_options.manifold_ownership<sp/>=<sp/>ceres::DO_NOT_TAKE_OWNERSHIP;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ceres::Problem<sp/>problem(problem_options);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>We<sp/>use<sp/>a<sp/>first<sp/>manif<sp/>helper<sp/>that<sp/>creates<sp/>a<sp/>ceres<sp/>cost-function.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>The<sp/>cost<sp/>function<sp/>computes<sp/>the<sp/>distance<sp/>between</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>the<sp/>desired<sp/>state<sp/>and<sp/>the<sp/>current<sp/>state</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Create<sp/>4<sp/>objectives<sp/>which<sp/>are<sp/>&apos;close&apos;<sp/>in<sp/>SE2.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::shared_ptr&lt;ceres::CostFunction&gt;<sp/>obj_pi_over_4<sp/><sp/><sp/>=<sp/>manif::make_objective_autodiff&lt;SE2d&gt;(3,<sp/>3,<sp/><sp/><sp/><sp/>M_PI/4.);</highlight></codeline>
<codeline><highlight class="normal">std::shared_ptr&lt;ceres::CostFunction&gt;<sp/>obj_3_pi_over_8<sp/>=<sp/>manif::make_objective_autodiff&lt;SE2d&gt;(3,<sp/>1,<sp/>3.*M_PI/8.);</highlight></codeline>
<codeline><highlight class="normal">std::shared_ptr&lt;ceres::CostFunction&gt;<sp/>obj_5_pi_over_8<sp/>=<sp/>manif::make_objective_autodiff&lt;SE2d&gt;(1,<sp/>1,<sp/>5.*M_PI/8.);</highlight></codeline>
<codeline><highlight class="normal">std::shared_ptr&lt;ceres::CostFunction&gt;<sp/>obj_3_pi_over_4<sp/>=<sp/>manif::make_objective_autodiff&lt;SE2d&gt;(1,<sp/>3,<sp/>3.*M_PI/4.);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">SE2d<sp/>average_state(0,0,0);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Add<sp/>residual<sp/>blocks<sp/>to<sp/>ceres<sp/>problem</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">problem.AddResidualBlock(<sp/>obj_pi_over_4.get(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>average_state.data()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">problem.AddResidualBlock(<sp/>obj_3_pi_over_8.get(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>average_state.data()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">problem.AddResidualBlock(<sp/>obj_5_pi_over_8.get(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>average_state.data()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">problem.AddResidualBlock(<sp/>obj_3_pi_over_4.get(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">nullptr</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>average_state.data()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>We<sp/>use<sp/>a<sp/>second<sp/>manif<sp/>helper<sp/>that<sp/>creates<sp/>a<sp/>ceres<sp/>local<sp/>parameterization</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>for<sp/>our<sp/>optimized<sp/>state<sp/>block.</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::shared_ptr&lt;ceres::Manifold&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>auto_diff_manifold<sp/>=</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>manif::make_manifold_autodiff&lt;SE2d&gt;();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">problem.SetManifold(<sp/>average_state.data(),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>auto_diff_manifold.get()<sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Run<sp/>the<sp/>solver!</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ceres::Solver::Options<sp/>options;</highlight></codeline>
<codeline><highlight class="normal">options.minimizer_progress_to_stdout<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">ceres::Solver::Summary<sp/>summary;</highlight></codeline>
<codeline><highlight class="normal">ceres::Solve(options,<sp/>&amp;problem,<sp/>&amp;summary);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;summary:\n&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>summary.FullReport()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">std::cout<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Average<sp/>state:\nx:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>average_state.x()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\ny:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>average_state.y()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\nt:&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>average_state.angle()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;\n\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
</programlisting> </para>
</sect1>
    </detaileddescription>
    <location file="pages/cpp/On-the-use-with-Ceres.md"/>
  </compounddef>
</doxygen>
